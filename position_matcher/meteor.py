import matplotlib.pyplot as plt
import pandas as pd
import xmltodict as xtd
from astropy.coordinates import *
import astropy.units as u
from astropy.time import Time
import datetime as dt
import os
from scipy.optimize import minimize
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
import numpy as np
import plotly.io as pio



class Meteor:
  """
    Class meteor contains functions for counting and plot trajectory of given meteor data
  
  """ 
  
  raw_df1 = None 
  raw_df2 = None 
  
  spf = 0.05
  
  df_with_trajectory=None
  
  stationELoc1 = None
  stationELoc2 = None
  
  name = None

  def __init__(self, path1, path2, station_coord1, station_coord2, name):

    self.stationELoc1 = self.__get_staton_eloc(station_coord1[0], station_coord1[1], station_coord1[2])
    self.stationELoc2 = self.__get_staton_eloc(station_coord2[0], station_coord2[1], station_coord2[2])

    self.name = name
    
    parsed_xml1 = self.__readARXMLFile(path1)
    parsed_xml2 = self.__readARXMLFile(path2)

    self.raw_df1 = self.__getSkyCoord(parsed_xml1, self.stationELoc1)
    self.raw_df2 = self.__getSkyCoord(parsed_xml2, self.stationELoc2)

    tmp_df = self.__get_time_intersection(self.raw_df1, self.raw_df2)
    
    self.df_with_trajectory = self.get_trajectory_df(tmp_df)
    
    
  def __get_staton_eloc(self, lon, lat, height):
    '''
      _get_staton_eloc function takes coordinates of station (camera) and returns Earthlocation object (astropy)
      :param lon: longtitude  
      :param lat: latitude
      :param height: height (in meters)
      :return: returns Earthlocation object
    '''
    return EarthLocation(lon=lon*u.deg, lat=lat*u.deg, height=height*u.m)
    
  def __readARXMLFile(self, xmlFilePath, zeroTime=None, zeroFrameTime=None):
        # reads data from XML file generated by MT after astrometric reduction
        # zeroTime and zeroFrameTime have to be datetime objects
        # zeroTime = time from which the seconds are counted (does not affect time of the zero frame)
        # if not given, the seconds are counted from the header time (EventStartTime)
        # zeroFrameTime = time of the zero frame (given if the header time / EventStartTime is wrong)
        # returns pandas DataFrame
        # col 0: FRAME NUMBER ... counted from EventStartTime (EventStartTime is time of the 0th frame)
        # CAUTION! frame number could be wrong! Internal "stuff" of AMOS-Capture S/W used to generate .yaml files
        # col 1: SECONDS ... counted from zeroTime
        # col 2: DATETIME ... time of the measurement as a datetime object, counted as zeroTime + seconds
        # col 3: AZIMUTH
        # col 4: ELEVATION/ALTITUDE
        # col 5: MAGNITUDE
        print(f"Reading {xmlFilePath} ... ", end="")
        with open(xmlFilePath, "rb") as xmlFile:
            xmlData = xtd.parse(xmlFile, xml_attribs=True)
        header = xmlData["ufoanalyzer_record"]
        if zeroFrameTime is not None:
            headerTime = zeroFrameTime
        else:
            headerTime = dt.datetime(int(header["@y"]), int(header["@mo"]), int(header["@d"]),
                                    int(header["@h"]), int(header["@m"]), int(float(header["@s"])),
                                    int(round((float(header["@s"])-int(float(header["@s"])))*10e5)))
            
        xmlData = pd.DataFrame(xmlData["ufoanalyzer_record"]["ua2_objects"]["ua2_object"]["ua2_objpath"]["ua2_fdata2"])
        arData = pd.DataFrame(columns=["fno", "sec", "datetime", "az", "ev", "mag"])
        arData["fno"] = xmlData.pop("@fno")
        arData["az"] = xmlData.pop("@az")
        arData["ev"] = xmlData.pop("@ev")
        arData["mag"] = xmlData.pop("@mag")
        if zeroTime is None:
            zeroTime = headerTime
        arData["sec"] = arData["fno"].to_numpy(dtype=int) * self.spf + (headerTime - zeroTime).total_seconds()
        for i, seconds in enumerate(arData["sec"]):
            arData.loc[i, "datetime"] = zeroTime + dt.timedelta(seconds=seconds)
        print("COMPLETE!")
        return arData
        
  def __getSkyCoord(self, arData, stationELoc):
    # converts azimuth and altitude/elevation to right-ascension and declination
    # returns pandas DataFrame
    # col 0: DATETIME/OBSTIME ... as astropy Time object
    # col 1: AZIMUTH ... corrected, from "unknown reason" MeteorTrajectory counts azimuth
    # from the south to the east, not from the north to the west (convention)
    # col 2: ELEVATION/ALTITUDE
    # col 3: RIGHT-ASCENSION ... topocentric
    # col 4: DECLINATION ... topocentric
    # col 5: LONGITUDE
    # col 6: LATITUDE
    
    obstimeArr = Time(arData["datetime"], format="datetime")
    
    print(f"Getting SkyCoords...", end="")
    
    #altaz = SkyCoord(az=(arData["az"].to_numpy(dtype=float) + 180) * u.deg,
    #                 alt=arData["ev"].to_numpy(dtype=float) * u.deg,
    #                 frame="altaz",
    #                 obstime=obstimeArr,
    #                 location=stationELoc,
    #                 unit="deg")


    altaz = SkyCoord(az=(arData["az"].to_numpy(dtype=float)) * u.deg,
                     alt=arData["ev"].to_numpy(dtype=float) * u.deg,
                     frame="altaz",
                     obstime=obstimeArr,
                     location=stationELoc,
                     unit="deg")
    

    radec = altaz.transform_to("gcrs")
    
    stationGCRSVectorArr = SkyCoord(stationELoc.get_gcrs(obstime=obstimeArr),
                                   frame="gcrs")

    gcrs = radec.cartesian + stationGCRSVectorArr.cartesian / u.m
    now = gcrs.copy() 

    scData = pd.DataFrame(columns=["obstime", "az[deg]", "alt[deg]", "ra[deg]", "dec[deg]"])
    scData["obstime"] = altaz.obstime.iso


    scData['station'] = stationGCRSVectorArr.cartesian / u.m
    scData['direcion_point'] = now
    
    print("COMPLETE!")
    
    return scData
  

  
  def __get_time_intersection(self, df1, df2):
    '''
      _get_time_intersection function finds intersection of observer time from observation of meteor taken from two cameras
      :param df1: dataframe where data from first camera are stored
      :param df2: dataframe where data from second camera are stored
      :return: returns dataframe which was created by merging two input dataframes with cutted obs time which wasnt in intersection
    '''
    df1['obstime'] = pd.to_datetime(df1['obstime'])
    df2['obstime'] = pd.to_datetime(df2['obstime'])

    ranges1 = df1['obstime'].agg(['min', 'max'])
    ranges2 = df2['obstime'].agg(['min', 'max'])

    df1 = df1[(df1['obstime'] >= ranges2['min']) & (df1['obstime'] <= ranges2['max'])]
    df2 = df2[(df2['obstime'] >= ranges1['min']) & (df2['obstime'] <= ranges1['max'])]
    
    
    return pd.merge(df1, df2, on = "obstime", how = "inner")
  
  

  
  
  def get_sublist(self, site1, site2, coord1, coord2):
      '''
      Calculate the coordinates of the point which is the closest point to the two optical vectors.

      :param site1: Cartesian coordinates of the first site, with origin in the middle of the Earth.
      :param site2: Cartesian coordinates of the second site, with origin in the middle of the Earth.
      :param coord1: Cartesian coordinates of the first meteor, with origin in observatory.
      :param coord2: Cartesian coordinates of the second meteor, with origin in observatory.
      :return: List of Cartesian coordinates of the point which is the closest point to the two optical vectors.
      '''
      site1 = np.array([site1.x, site1.y, site1.z])
      site2 = np.array([site2.x, site2.y, site2.z])
      coord1 = np.array([coord1.x, coord1.y, coord1.z])
      coord2 = np.array([coord2.x, coord2.y, coord2.z])

      # Calculate the direction vector of the unit vector which is defined by point of site and meteor
      dir1 = coord1 - site1
      dir2 = coord2 - site2

      
      def get_distance(self, one,two) :

        [x1,y1,z1] = one # first coordinates
        [x2,y2,z2] = two # second coordinates

        return (((x2-x1)**2)+((y2-y1)**2)+((z2-z1)**2))**(1/2)

      def closest_points_between_two_lines(p1, d1, p2, d2):
        """
        Calculate the closest points between two skew lines in 3D space.

        :param p1: a point on the first line
        :param d1: the direction vector of the first line
        :param p2: a point on the second line
        :param d2: the direction vector of the second line

        :return: a tuple containing the closest points on each line
        """

        # Calculate the normal vector to both direction vectors
        n = np.cross(d1, d2)

        # Check if the lines are skew (i.e., the cross product is not zero)
        if np.allclose(n, [0, 0, 0]):
          #raise ValueError("Lines are parallel or coincident.")
          # p1, p2 are points on the lines
          # d1, d2 are direction vectors of the lines
          # returns the intersection point of the two lines
          print(p1,d1,p2,d2)
          n1 = np.cross(d1, d2)
          n2 = np.cross(d1, n1)
          t = np.dot(n2, p2 - p1) / np.dot(n2, d1)
          intersection_point =  p1 + t * d1
          print(intersection_point)
          return [[intersection_point[0],intersection_point[1], intersection_point[2]], 0]
          

        # Calculate the cross product between the normal vector and direction vector of the first line
        
        n1 = np.cross(n, d1)

        # Calculate the cross product between the normal vector and direction vector of the second line
        n2 = np.cross(n, d2)

        

        # Calculate the coordinates of the point where the two lines are closest
        c1 = p1 + np.dot((p2 - p1), n2) / np.dot(d1, n2) * d1

        # Calculate the coordinates of the point where the two lines are closest
        c2 = p2 + np.dot((p1 - p2), n1) / np.dot(d2, n1) * d2

        print('pointss')
        print(c1,c2)

        midpoint = (c1 + c2) / 2
        
        dst = get_distance(self, c1,c2)

        return midpoint, dst


      # Calculate the closest points on the two lines
      midpoint, dst = closest_points_between_two_lines(site1, dir1, site2, dir2)
      
      print(midpoint)
      return [[midpoint[0], midpoint[1], midpoint[2]], dst]

    
  def get_trajectory_df(self, df):
    df[['real_coords','distance']] = df.apply(lambda x: self.get_sublist(x.station_x, x.station_y, x.direcion_point_x, x.direcion_point_y), axis=1, result_type="expand")
    
    return df
  
  def plot_trajectory(self):
    '''
      _plot_trajectory this function will plot trajecory of given meteor
    '''
 

    ax  = []
    fig = plt.figure()
    ax = fig.add_subplot(projection='3d')

    x= np.array(self.df_with_trajectory.real_coords.to_list())[:,0] 
    y = np.array(self.df_with_trajectory.real_coords.to_list())[:,1] 
    z = np.array(self.df_with_trajectory.real_coords.to_list())[:,2] 
    
    x = x[~np.isinf(x)]
    y = y[~np.isinf(y)]

    z = z[~np.isinf(z)]
    
    colors = px.colors.sequential.Plasma
    colors[0], colors[1], colors[2] = ['red', 'green', 'blue']
    fig = px.scatter_3d(x=x, y=y, z=z, color_discrete_sequence=colors, height=500, width=1000)
    fig.update_traces(marker=dict(size=3, line=dict(color='black', width=0.1)))

    # set the layout
    fig.update_layout(scene=dict(
            xaxis=dict(backgroundcolor='white',
                      title='x [m]',
                      color='black',
                      gridcolor='#f0f0f0',
                      title_font=dict(size=10),
                      tickformat=',.0f', 
                      tickfont=dict(size=10)),
            yaxis=dict(backgroundcolor='white',
                      color='black',
                      title='y [m]',
                      gridcolor='#f0f0f0',
                      title_font=dict(size=10),
                      tickformat=',.0f', 
                      tickfont=dict(size=10)),
            zaxis=dict(backgroundcolor='lightgrey',
                      color='black', 
                      gridcolor='#f0f0f0',
                      title='z [m]',
                      title_font=dict(size=10),
                      tickfont=dict(size=10),
                      tickformat=',.0f')),
            showlegend=False,
            margin=dict(l=0, r=0, b=0, t=0))



    fig.update_layout(scene=dict(xaxis=dict(range=[np.min(x), np.max(x)]),
                                  yaxis=dict(range=[np.min(y), np.max(y)]),
                                  zaxis=dict(range=[np.min(z), np.max(z)])))
    
    
    fig.update_layout(title=f'{self.name} trajectory in carthesian coordinate system')
    #pio.write_image(fig, f"{self.name}_trajectory.jpg")

    fig.show()

  
  def plot_distances(self):
      
      '''
        _plot_distance plot distance in time of seen meteor from centre of earth 
      '''
 


      ax  = []
      fig = plt.figure()
      ax = fig.add_subplot()

      x = self.df_with_trajectory.obstime.to_list()

      def mag(x):
        return np.sqrt(x.dot(x))

      distances = np.array([mag(x) for x in np.array(self.df_with_trajectory.real_coords.to_list())])  
              
      ax.scatter(x,distances)
      ax.set_ylabel('distances from core of the earth [km]')
      ax.set_xlabel('observatory time')


      formatted_y = [f"{'{:,.0f}'.format(val / 1000)}" for val in distances]



      ax.tick_params(axis='both', which='major', labelsize=10, pad=18)
      # Plot the data

      ax.set_yticklabels(formatted_y)



      fig.set_size_inches(8, 6)  # Specify figure size herea

      plt.title(f'{self.name} magnitude of meteor vector pointing to meteor from earth')

      plt.savefig(f"{self.name}_distances.jpg")
      
  def plot_distance_from_sites(self):
    '''
        this function plots distance meteor from both sites
        it needs:
        real_coords: pandas column of coords of meteor
        site1_coords: pandas column of coords of site coords
        site2_coords: pandas column of site2 coords
    '''

                          
    def get_distances_from_stations(site, realcoords):
      site = np.array([site.x, site.y, site.z])
      realcoords = np.array(realcoords
                            )
      def get_distance(one,two) :

          [x1,y1,z1] = one # first coordinates
          [x2,y2,z2] = two # second coordinates

          return (((x2-x1)**2)+((y2-y1)**2)+((z2-z1)**2))**(1/2)

      return get_distance(realcoords, site)
    
    y1  =[get_distances_from_stations(x,y) for x,y in  zip(self.df_with_trajectory.station_x.to_list(), self.df_with_trajectory.real_coords.to_list())]

    y2 = [get_distances_from_stations(x,y) for x,y in  zip(self.df_with_trajectory.station_y.to_list(), self.df_with_trajectory.real_coords.to_list())]



    ax  = []
    fig = plt.figure()
    ax = fig.add_subplot()

    x = self.df_with_trajectory.obstime.to_list()
      
    ax.scatter(x,y1,label='site 1')
    ax.scatter(x,y2, label='site 2')

    ax.set_ylabel('distances from stations [m]')
    ax.set_xlabel('observatory time')

    ax.tick_params(axis='both', which='major', labelsize=10, pad=18)
    ax.legend()
    # Plot the data

    fig.set_size_inches(8, 6)  # Specify figure size herea

    plt.title(f'{self.name} meteor distance from both sites')
      
  def plot_err(self):
      '''
          this function fit line to a data column (real coord) and will find error of data 
        '''
              
      # getting data
      x = np.array(self.df_with_trajectory.real_coords.to_list())[:,0] 
      y = np.array(self.df_with_trajectory.real_coords.to_list())[:,1] 
      z = np.array(self.df_with_trajectory.real_coords.to_list())[:,2] 

      data = np.concatenate((x[:, np.newaxis], 
                            y[:, np.newaxis], 
                            z[:, np.newaxis]), 
                            axis=1)

      # Calculate the mean of the points, i.e. the 'center' of the cloud
      datamean = data.mean(axis=0)

      # Do an SVD on the mean-centered data.
      uu, dd, vv = np.linalg.svd(data - datamean)

      # Now vv[0] contains the first principal component, i.e. the direction
      # vector of the 'best fit' line in the least squares sense.

      # Now generate some points along this best fit line, for plotting.
      linepts = vv[0] * np.mgrid[-40000:40000:40000j][:, np.newaxis]
      
      # shift by the mean to get the line in the right place
      linepts += datamean

      # plot the scatter plot
      colors = px.colors.sequential.Plasma
      colors[0], colors[1], colors[2] = ['red', 'green', 'blue']
      fig = px.scatter_3d(x=x, y=y, z=z, color_discrete_sequence=colors, height=500, width=1000)
      fig.update_traces(marker=dict(size=3, line=dict(color='black', width=0.1)))

      # plot the line
      fig.add_trace(go.Scatter3d(
          x=linepts[:, 0],
          y=linepts[:, 1],
          z=linepts[:, 2],
          mode='lines',
          name='best fit line',
          line=dict(color='blue', width=5)
      ))

      # set the layout
      fig.update_layout(scene=dict(
              xaxis=dict(backgroundcolor='white',
                        title='x [m]',
                        color='black',
                        gridcolor='#f0f0f0',
                        title_font=dict(size=10),
                        tickformat=',.0f', 
                        tickfont=dict(size=10)),
              yaxis=dict(backgroundcolor='white',
                        color='black',
                        title='y [m]',
                        gridcolor='#f0f0f0',
                        title_font=dict(size=10),
                        tickformat=',.0f', 
                        tickfont=dict(size=10)),
              zaxis=dict(backgroundcolor='lightgrey',
                        color='black', 
                        gridcolor='#f0f0f0',
                        title='z [m]',
                        title_font=dict(size=10),
                        tickfont=dict(size=10),
                        tickformat=',.0f')),
              showlegend=False,
              margin=dict(l=0, r=0, b=0, t=0))



      fig.update_layout(scene=dict(xaxis=dict(range=[np.min(x), np.max(x)]),
                                    yaxis=dict(range=[np.min(y), np.max(y)]),
                                    zaxis=dict(range=[np.min(z), np.max(z)])))


      fig.update_layout(title=f'{self.name} error in data')

      #pio.write_image(fig, f"{self.name}_error.jpg")
      # show the plot
      fig.show()

      def count_dist(x,y,z):
          line_point = np.array([0, 0, 0]) + datamean
          line_direction = vv[0] 

          # Define the point
          point = np.array([x,y,z])
          
          x = point - line_point

          t = x.dot(line_direction)
          
          def get_distance(one,two) :

              [x1,y1,z1] = one # first coordinates
              [x2,y2,z2] = two # second coordinates

              return (((x2-x1)**2)+((y2-y1)**2)+((z2-z1)**2))**(1/2)
          
          p = line_point + t*line_direction
          
          
          # Compute the distance
          #distance = np.linalg.norm(np.cross((point - line_point), line_direction)) / np.linalg.norm(line_direction)
          return get_distance(p, point)

      print(f'error = {np.sum([count_dist(x[i], y[i], z[i]) for i in range(0, len(x))]) / len(x)}')